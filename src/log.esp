void extern mqtt_publish_event(JsonObject *root);

void ICACHE_FLASH_ATTR writeEvent(String type, String src, String desc, String data) {
	DynamicJsonBuffer jsonBuffer;
	JsonObject &root = jsonBuffer.createObject();
	root["type"] = type;
	root["src"] = src;
	root["desc"] = desc;
	root["data"] = data;
	root["time"] = now();
	if ((mqttEvents) && (mqttenabled==1)){  // log to MQTT
        root["cmd"] = "event";
		root["door"] = deviceHostname;																																																																					
		mqtt_publish_event(&root);
	}
	else  // log to file
	{
		File eventlog = SPIFFS.open("/eventlog.json", "a");
		root.printTo(eventlog);
		eventlog.print("\n");
		eventlog.close();
	}
}


void ICACHE_FLASH_ATTR writeLatest(String uid, String username, int acctype) {
	DynamicJsonBuffer jsonBuffer;
	JsonObject &root = jsonBuffer.createObject();
	root["uid"] = uid;
	root["username"] = username;
	root["acctype"] = acctype;
	root["timestamp"] = now();
	if ((mqttEvents) && (mqttenabled==1)){  // log to MQTT
        //root["cmd"] = "access";
		//mqtt_publish_event(&root);
	}
	else  // log to file
	{
		File latestlog = SPIFFS.open("/latestlog.json", "a");
		root.printTo(latestlog);
		latestlog.print("\n");
		latestlog.close();
	}
}

size_t lastPos;   // position counter for fast seek
#define LOGTYPE_LATESTLOG 0
#define LOGTYPE_EVENTLOG  1
#define ITEMS_PER_PAGE 10

void ICACHE_FLASH_ATTR sendLogFile(int page,String fileName,int logFileType) {

	// if we are reading the first page then we reset
	// the position counter 

	if (page ==1) lastPos=0;
	float pages;
	DynamicJsonBuffer jsonBuffer;
	JsonObject &root = jsonBuffer.createObject();
	if (logFileType == LOGTYPE_EVENTLOG) root["command"] = "eventlist";
	if (logFileType == LOGTYPE_LATESTLOG) root["command"] = "latestlist";
	root["page"] = page;
	JsonArray &items = root.createNestedArray("list");
	File logFile = SPIFFS.open(fileName, "r");

	// move the file pointer to the last known position

	logFile.seek(lastPos);
	int numLines=0;

	// read in 10 lines or until EOF whatever happens first 

	while (logFile.available() && (numLines < ITEMS_PER_PAGE))
	{
		String item = String();
		item = logFile.readStringUntil('\n');
		items.add(item);
		numLines++;
	}

	// remember the last position

	lastPos = logFile.position();

	// calculate the number of remaining pages

	if (logFile.available()) // tell bootstrap footable on the client side that there are more pages to come
	{
		float bytesPerPageRoughly = (lastPos / page);
		float totalPagesRoughly = logFile.size () / bytesPerPageRoughly;
		pages= totalPagesRoughly <= page ? page + 1 : totalPagesRoughly ; 
	}
	else pages=page; // this was the last page

	logFile.close();
	root["haspages"] = ceil(pages);
	size_t len = root.measureLength();
	AsyncWebSocketMessageBuffer *buffer = ws.makeBuffer(len);
	if (buffer) {
		root.printTo((char *)buffer->get(), len + 1);
		ws.textAll(buffer);
		if (logFileType == LOGTYPE_EVENTLOG) ws.textAll("{\"command\":\"result\",\"resultof\":\"eventlist\",\"result\": true}");
		if (logFileType == LOGTYPE_LATESTLOG) ws.textAll("{\"command\":\"result\",\"resultof\":\"latestlist\",\"result\": true}");
		
	}
}

void ICACHE_FLASH_ATTR sendEventLog(int page) {

	sendLogFile(page,"/eventlog.json",LOGTYPE_EVENTLOG);
}

void ICACHE_FLASH_ATTR sendLatestLog(int page) {

	sendLogFile(page,"/latestlog.json",LOGTYPE_LATESTLOG);
}
